%% ------------------------------------------------------------------------- %%
\chapter{Test-Driven Development}
\label{cap:tdd}

Métodos ágeis de desenvolvimento de software focam em constante
\textit{feedback}, seja ele da equipe em relação ao cliente, seja da equipe em relação à
qualidade (interna e externa) do código produzido \cite{AgileManifesto}. Por
esse motivo, muitas das práticas sugeridas por métodos ágeis visam aumentar a 
quantidade e a qualidade desse \textit{feedback}; a ideia da programação pareada, por
exemplo, é dar \textit{feedback} sobre o código durante sua escrita.

Test-Driven Development (TDD), popularizada por Kent Beck por meio de seu livro
\textit{TDD: By Example} em 2001 \cite{TDDByExample}, é mais uma das práticas
ágeis na qual o foco é dar \textit{feedback}. TDD tem grande importância durante o ciclo
de desenvolvimento uma vez que, conforme sugerido pelas práticas ágeis, o \textit{design} de um
software deve emergir à medida que o software cresce. E, para responder
rapidamente a essas alterações, é necessário um constante \textit{feedback} sobre a
qualidade interna e externa do código.

As diversas práticas da Programação Extrema provêm \textit{feedbacks} sobre pontos diferentes 
do projeto e em diferentes escalas. 
A velocidade em que a prática de TDD dá \textit{feedback} ao desenvolvedor possibilita que o mesmo
tome decisões sobre o código enquanto o custo de mudança ainda é
baixo. Segundo Vanderburg \cite{vanderburg}, TDD dá \textit{feedback} em questão de
minutos e, em questão de tempo, só é inferior à programação pareada. O gráfico,
baseado no trabalho dele, pode ser visto na Figura
\ref{fig:agile-feedback}.

\begin{figure}
  \centering
  \includegraphics[scale=0.4]{agile-feedback-port}
  \caption{Práticas de XP e Tempo de \textit{Feedback} (baseado em \cite{vanderburg})}
  \label{fig:agile-feedback}
\end{figure}

TDD é uma prática de desenvolvimento de software que se baseia na repetição de
um pequeno ciclo de atividades. Primeiramente, o desenvolvedor escreve um
teste que falha. Em seguida, deve fazê-lo passar, implementando a
funcionalidade desejada. Por fim, refatora o código para remover toda e qualquer
duplicação de dados ou de código gerada pelo processo.
Além disso, simplicidade deve ser também algo intrínseco ao processo; o praticante
deve buscar sempre escrever o teste mais simples que falhe e escrever a implementação mais simples
que faça o teste passar.
Esse ciclo
é também conhecido como 
"Vermelho-Verde-Refatora" (ou \textit{"Red-Green-Refactor"}), uma vez que lembra as cores que um 
desenvolvedor normalmente vê quando faz TDD: o vermelho geralmente significa que
o teste está falhando, e o verde quando o teste foi executado com sucesso.

Este capítulo aborda a prática de TDD, bem como cita
seus possíveis efeitos no processo de desenvolvimento de software, conforme relatado pela
literatura.

%% ------------------------------------------------------------------------- %%
\section{TDD como uma Prática de Testes}

Uma consequência da prática de TDD é a bateria de testes de unidade gerada.
A prática ajuda o programador a evitar erros de regressão, em que a implementação de
uma nova funcionalidade quebra uma outra funcionalidade já existente no sistema.
Essa bateria também provê segurança durante as
constantes refatorações de código que são feitas durante o processo de
desenvolvimento, e possibilita que ele altere o \textit{design} e garanta que o
comportamento ainda seja o mesmo. 
A quantidade de código coberto pelos testes também tende a ser alta, uma vez que o
desenvolvedor deve sempre escrever um teste antes de implementar uma nova
funcionalidade. Além disso, por sua execução ser bastante rápida, a bateria é executada
muitas vezes ao dia, dando \textit{feedback} constante ao programador.

Em projetos novos, praticantes de TDD afirmam que sentem menos necessidade da
utilização de recursos de depuração de código \cite{george-williams-experiment} 
\cite{janzen-arch-improvement}. 
A quantidade de código
escrita entre um teste e outro tende a ser pequena, e caso um teste falhe
inesperadamente, o programador pode simplesmente reverter as alterações para a 
versão anterior estável e começar novamente. Essa abordagem pode muitas vezes
ser mais produtiva do que a atividade de depuração 
\cite{janzen-arch-improvement}. Por essas e outras razões, desenvolvedores afirmam 
que são mais produtivos quando praticam TDD. Apesar de o custo da escrita do teste
existir, a longo prazo o desenvolvedor gasta menos tempo com depurações ou 
erros de regressão, e com isso tem sua produtividade aumentada
\cite{george-e-williams}.

%% ------------------------------------------------------------------------- %%
\section{TDD como Prática de Design de Classes}
\label{cap:tdd-e-design}

É comum relacionar TDD à práticas de testes de software. No entanto, apesar de constar o
termo ``teste'' no nome, TDD não é visto apenas como uma prática de testes.
Embora a criação de testes seja algo intrínseco ao processo, é dito que TDD também 
auxilia o desenvolvedor a criar classes mais flexíveis, mais coesas e
menos acopladas. Os testes são a ferramenta que o programador utiliza para
validar o \textit{design} criado. Por esse motivo, muitos se referem a TDD como
\textit{Test-Driven Design}, ou seja, \textit{design} guiado pelos testes
\cite{tdd-taxonomy}.

Muitos autores como Kent Beck \cite{aim-fire}, Dave Astels \cite{astels-tdd} e
Robert Martin \cite{bob-martin} afirmam inclusive que TDD é na verdade uma prática de
\textit{design} \cite{tdd-taxonomy} \cite{aim-fire}.
Na opinião desses autores, a mudança na ordem do ciclo de
desenvolvimento tradicional, apesar de simples, agrega diversos outros
benefícios ao código produzido: maior simplicidade, menor acoplamento e maior
coesão das classes criadas, levando a um melhor \textit{design}, entre
outros. Ward Cunningham, um dos pioneiros da Programação Extrema, resume essa 
discussão em uma frase: \textit{"Test-First programming is not a testing technique"} 
que, em uma tradução livre, significa \textit{"Escrever primeiro os testes
não é uma prática de testes"}.

No entanto, é possível encontrar muitas definições que
não levam isso em conta. Algumas delas consideram apenas a ideia da
inversão da ordem de desenvolvimento, na qual o programador primeiro
escreve o teste e depois escreve o código que o faça passar.

Um exemplo é a definição que pode ser encontrada no livro \textit{JUnit
in Action} \cite{junit-in-action}: \textit{"Test-Driven Development é uma
prática de programação que instrui desenvolvedores a escrever código novo
apenas se um teste automatizado estiver falhando, e a eliminar duplicação. O
objetivo de TDD é 'código claro que funcione'"}.

Janzen levantou esse problema nas definições e culpa até o próprio nome da prática, uma vez
que ela possui a palavra ``testes'', mas não contém a palavra \textit{``design''} 
\cite{tdd-really-improve}.

Segundo ele, uma definição mais clara é a de que TDD é a arte de produzir testes
automatizados para código de produção, usando esse processo para guiar o \textit{design} e a programação.
Para cada pequeno pedaço de funcionalidade, o desenvolvedor deve primeiro
escrever um teste que especifique e valide o que o código irá fazer. O
programador então produz somente o código necessário para fazer esse teste
passar. Em seguida, ele refatora (simplifica e clareia) tanto o código de produção
quanto o código de testes \cite{agilealliance-tdd} \cite{tdd-taxonomy}.

%% ------------------------------------------------------------------------- %%
\subsection{Possíveis Efeitos no \textit{Design} de Classes}

Como mencionado acima, os praticantes de TDD acreditam que os testes de unidade
podem ajudá-los a criar um design de classes de qualidade. Uma das explicações mais
populares para esse fenômeno é a relação
entre um código que possui uma alta testabilidade, ou seja, é fácil de ser testado
por meio de um teste de unidade, e um design de classes de alta qualidade.
Segundo Feathers \cite{feathers-synergy}, 
por causa dessa sinergia muito
grande entre uma classe com alta testabilidade e um bom \textit{design de classes}: se o
programador busca por testabilidade, acaba criando um bom \textit{design de classes}; se 
busca por um bom \textit{design de classes}, acaba escrevendo classes mais
testáveis.

TDD também sugere que o programador dê sempre pequenos passos (conhecidos pelo termo em
inglês, \textit{baby steps}): deve-se escrever testes sempre para a menor
funcionalidade possível, escrever o código mais simples que faça o teste passar
e fazer sempre apenas uma refatoração por vez \cite{TDDByExample}.

Uma justificativa para tal é a de que, quanto maior o passo que o programador dá, mais
tempo ele leva para concluí-lo e, consequentemente, ele fica mais tempo
sem \textit{feedback} sobre o código. Além disso, faz com que o programador não crie
soluções mais complexas do que elas precisam ser, tornando o código, a longo
prazo, o mais simples possível.

No entanto, apesar de muito ser dito sobre os efeitos de design, e alguns deles
até serem demonstrados em estudos (conforme citado no Capítulo \ref{cap:trabalhos-relacionados}), 
pouco se sabe como a prática realmente influencia os desenvolvedores no momento da criação do
design das classes.

Mas, antes de estudar sobre a possível influência positiva da prática de TDD no design de classes,
é preciso primeiro definir o que é design de classes de qualidade. Por esse motivo, o 
próximo capítulo
discute bons príncipios de design de classes orientados a objetos, que serão utilizados
na avaliação dos códigos produzidos pelos participantes deste estudo.