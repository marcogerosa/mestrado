%% ------------------------------------------------------------------------- %%
\chapter{TDD e sua influência no design}
\label{cap:design}

\section{Introdução}
\label{sec:design-introducao}

Conforme discutido no capítulo \ref{cap:tdd}, TDD é uma pratica focada em design, e não em testes.
Ao escrever um teste antes do código, os programadores contemplam e decidem não somente sobre a interface (como nomes de classes e 
métodos, tipos de retorno e exceções lançadas), mas também no comportamento que se espera de uma determinada classe 
(como o resultado esperado de acordo com determinadas entradas) [TODO 13].

Conforme o sistema é desenvolvido, TDD possibilita um feedback sobre a qualidade tanto da implementação quanto do design. Segundo 
Freeman \cite{GOOS}, escrever testes (i) clarifica o critério de aceitação para o próximo pedaço de software; (ii) encoraja o programador
a escrever componentes fracamente acoplados, de maneira que eles possam ser testados de maneira isolada, e em um nível maior, combinados
com outros componentes; (iii) cria uma especificação executável sobre o que o código faz; e (iv) cria uma suíte de testes de regressão.
Já o processo de rodar os testes possibilita (i) a detecção de erros enquanto o contexto está recente na mente do programador, e (ii)
faz com que o programador saiba quando terminou seu trabalho, diminuindo assim o risco de implementar funcionalidades desnecessárias.

Como sugerido pelas práticas ágeis,
o design de um software deve emergir junto com sua evolução. E, para responder rapidamente à essas mudanças, é necessário
um feedback constante sobre a qualidade do design. Por esse motivo, TDD é considerado uma importante prática na Programação 
Extrema (XP) \cite{XPExplained} e uma estratégia essencial para designs emergentes.

O objetivo deste capítulo é discutir sobre design de software, apresentando
bons príncipios de design orientado a objetos, métricas e heurísticas de design, relacionando-os com a possível influência 
que TDD tem sobre estes pontos.

\section{Design}

\section{Princípios de Design}
\label{sec:design-oo-principios}


Como comentado por Martin \cite{bob-martin}, esses príncipios são produto de décadas de experiência em engenharia de software.
Eles não são produto de uma única pessoa, mas sim a integração de pensamentos e trabalhos de um grande número de
desenvolvedores de software e pesquisadores.

\section{Métricas de design}

\section{Heurísticas de designs}

\section{Sintomas de Designs em Degradação}

Quando um design começa a ficar difícil de ser evoluído, o reúso de código se torna mais complicado do que repetir o trecho de código ou 
o custo de se fazer qualquer alteraçõ no design se torna alto, dizemos que que esse design está \textit{degradando}. 
Martin \cite{bob-martin} enumerou alguns sintomas de designs em degradação, chamados também de \textit{maus cheiros de design}. 
Esses sintomas são parecidos com os maus cheiros de código \textit{code smells}, mas em um nível mais alto: esses sintomas
estão presentes na estrutura geral do software ao invés de estarem em apenas um pequeno trecho de código.

Esses sintomas podem ser medidos de forma subjetiva e algumas vezes de forma até objetiva. Geralmente, esses sintomas são causados
por violações de um ou mais príncipios de design, apresentados na seção \ref{sec:design-oo-principios}. 

\subsection{Rigidez}

Rigidez é a tendência do software em se tornar difícil de mudar, mesmo de maneiras simples. Toda mudança causa uma cascata de mudancçs subsequentes em módulos dependentes. Quanto mais módulos precisam ser modificados, maior é a rigidez do design. Quando um design está muito rígido, não se sabe com segurança quando uma mudança terá fim. Mudanças simples passam a demorar muito tempo até serem aplicadas no código e frequentemente acabam superando em várias vezes a estimativa de esforço inicial. Frases como \textit{"isto foi muito mais complicado do que eu imaginei"} tornam-se populares. Neste momento, gerentes de desenvolvimento começam a ficar receosos em permitir que os desenvolvedores consertem problemas não críticos.


\subsection{Fragilidade}

Fragilidade é a tendência do software em quebrar em muitos lugares diferentes toda vez que uma única mudança acontece. Frequentemente, os novos problemas ocorrem em áreas não relacionadas conceitualmente com a área que foi mudada, tornando o processo de manutenção demasiadamente custoso, complexo e tedioso. Consertar os novos problemas usualmente passa a resultar em outros novos problemas e assim por diante. Infelizmente, módulos frágeis são comuns em sistemas de software. São estes os módulos que sempre aparecem na lista de bugs a serem corrigidos. Além disto, desenvolvedores começam a ficar receosos de alterar certos trechos de código, pois sabem que estes estão tão frágeis que qualquer mudança simples fatalmente acarretará na introdução de problemas inesperados e de naturezas diversas. 


\subsection{Imobilidade}

Imobilidade é a impossibilidade de se reusar software de outros projetos ou de partes do mesmo projeto. Neste cenário, o módulo que se deseja reutilizar frequentemente tem uma bagagem muito grande de dependências e não possui código claro. Depois de muita investigação, os arquitetos descobrem que o trabalho e o risco de separar as partes desejáveis das indesejáveis são tão grandes, que o módulo acaba sendo reescrito ao invés de reutilizado.

\subsection{Viscosidade}

Quando uma mudança deve ser realizada, usualmente há várias opções para realizar tal mudança. Quando as opções que preservam o design são mais difíceis de serem implementadas do que aquelas que não o preservam (hacks), há alta viscosidade de design. Neste cenário, é fácil fazer a "coisa errada" e é difícil fazer a "coisa certa", ou seja, é difícil preservar e aprimorar o design.

\subsection{Complexidade Desnecessária}

Detecta-se complexidade desnecessária no design quando ele contém muitos elementos inúteis ou não utilizados (\textit{dead code}). Geralmente ocorre quando há muito design inicial (\textit{up-front design}) e não se segue uma abordagem de desenvolvimento iterativa e incremental, de modo que os projetistas tentam prever uma série de futuros requisitos para o sistema e concebem um design demasiadamente flexível ou desnecessariamente sofisticado. Frequentemente apenas algumas previsões acabam se concretizando ao longo do tempo e, neste meio período, o design carrega o peso de elementos e construções não utilizados. O software então se torna complexo e difícil de ser entendido. Design com complexidade muito alta comumente afeta a produtividade, porque quando os desenvolvedores herdam tal projeto, eles gastam muito tempo aprendendo as nuances do design antes que possam efetivamente estendê-lo ou mantê-lo confortavelmente \cite{kerievsky}.

\subsection{Repetição Desnecessária}

Este é um fenômeno presente na grande maioria dos sistemas de software de médio e grande porte. Quando há repetição de trechos de código, é sinal de que uma abstração apropriada não foi capturada durante o processo de design (ou inclusive na análise). Descobrir esta abstração para eliminar a repetição de código geralmente não está na lista de itens de alta prioridade dos desenvolvedores, de maneira que a resolução do problema acaba sendo eternamente postergada. Também, o sistema se torna cada vez mais difícil de entender e principalmente de manter, pois os problemas encontrados em uma unidade de repetição devem ser corrigidos potencialmente em toda repetição, com o agravante de que uma repetição pode ter forma ligeiramente diferente de outra.

\subsection{Opacidade}

Opacidade é a tendência de um módulo ser difícil de ser entendido. Códigos podem ser escritos de maneira clara e expressiva ou de maneira "opaca" e complicada.
A tendência de um código é se tornar mais e mais opaco a medida que o tempo passa e, para que isso seja evitado, é necessário um esforço constante em 
manter esse código claro e expressivo. Uma maneira para prevenir isso, é fazer com que os desenvolvedores se ponham no papel de leitores do código e
refatorem esse código de maneira que qualquer outro leitor poderia entender. Além disso, revisões de código feita por outros desenvolvedores é também
uma possível solução para manter o código menos opaco.


\section{TDD e Design}
2 vantagens gratuitas; gerenciamento de dependencias e codigo facilmente invocavel
experiencia do programador para refatoracao de nivel maior
exemplo da classe de nota fiscal
falar sobre feedback do design
sinergia entre alta testabilidade e codigo bom
