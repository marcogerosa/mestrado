%% ------------------------------------------------------------------------- %%
\chapter{Design de Sistemas Orientados a Objetos}
\label{cap:design}

\section{Introdução}
\label{sec:design-introducao}

Este capítulo visa discutir alguns príncipios e boas práticas de orientação a objetos. Desenvolver sistemas orientados a objetos
não é uma tarefa fácil, já que criar classes, ou em um nível maior de abstração, módulos que possuam um baixo acoplamento
e uma alta coesão demanda um esforço muito grande do desenvolvedor. É muito comum que, após algum tempo de desenvolvimento,
o design perca qualidade e qualquer tipo de manutenção torne-se difícil e, por consequência, cara.

Na primeira parte, esse capítulo discute alguns sintomas de designs em degradação (também conhecidos como maus cheiros de design), 
e em seguida alguns príncipios que visam combater esses sintomas. Por fim, o capítulo discute métricas e heurísticas 
de design que são utilizadas no processo de análise das entrevistas e dos códigos.

\section{Design}


\section{Sintomas de Designs em Degradação}
\label{sec:design-degradacao}
Quando um design começa a ficar difícil de ser evoluído, o reúso de código se torna mais complicado do que repetir o trecho de código ou 
o custo de se fazer qualquer alteraçõ no design se torna alto, dizemos que que esse design está \textit{degradando}. 
Martin \cite{bob-martin} enumerou alguns sintomas de designs em degradação, chamados também de \textit{maus cheiros de design}. 
Esses sintomas são parecidos com os maus cheiros de código \textit{code smells}, mas em um nível mais alto: esses sintomas
estão presentes na estrutura geral do software ao invés de estarem em apenas um pequeno trecho de código.

Esses sintomas podem ser medidos de forma subjetiva e algumas vezes de forma até objetiva. Geralmente, esses sintomas são causados
por violações de um ou mais príncipios de design, apresentados na seção \ref{sec:design-oo-principios}. 

Muitos desses problemas são relacionados à gerência de dependências e, como comentado por Martin em
uma de suas palestras \cite{bobmartin-infoq}, gerenciar dependências é um dos maiores problemas do processo de desenvolvimento de software.
Quando essa atividade não é feita corretamente, isso gera código que é difícil de manter e reusar. Entretanto, quando essa atividade
é bem feita, o software tende a ser flexível, robusto e suas partes reusáveis.

\subsection{Rigidez}
\label{subsec:rigidez}

Rigidez é a tendência do software em se tornar difícil de mudar, mesmo de maneiras simples. Toda mudança causa uma cascata de mudancçs subsequentes em módulos dependentes. Quanto mais módulos precisam ser modificados, maior é a rigidez do design. Quando um design está muito rígido, não se sabe com segurança quando uma mudança terá fim. Mudanças simples passam a demorar muito tempo até serem aplicadas no código e frequentemente acabam superando em várias vezes a estimativa de esforço inicial. Frases como \textit{"isto foi muito mais complicado do que eu imaginei"} tornam-se populares. Neste momento, gerentes de desenvolvimento começam a ficar receosos em permitir que os desenvolvedores consertem problemas não críticos.


\subsection{Fragilidade}
\label{subsec:fragilidade}

Fragilidade é a tendência do software em quebrar em muitos lugares diferentes toda vez que uma única mudança acontece. Frequentemente, os novos problemas ocorrem em áreas não relacionadas conceitualmente com a área que foi mudada, tornando o processo de manutenção demasiadamente custoso, complexo e tedioso. Consertar os novos problemas usualmente passa a resultar em outros novos problemas e assim por diante. Infelizmente, módulos frágeis são comuns em sistemas de software. São estes os módulos que sempre aparecem na lista de bugs a serem corrigidos. Além disto, desenvolvedores começam a ficar receosos de alterar certos trechos de código, pois sabem que estes estão tão frágeis que qualquer mudança simples fatalmente acarretará na introdução de problemas inesperados e de naturezas diversas. 


\subsection{Imobilidade}

Imobilidade é a impossibilidade de se reusar software de outros projetos ou de partes do mesmo projeto. Neste cenário, o módulo que se deseja reutilizar frequentemente tem uma bagagem muito grande de dependências e não possui código claro. Depois de muita investigação, os arquitetos descobrem que o trabalho e o risco de separar as partes desejáveis das indesejáveis são tão grandes, que o módulo acaba sendo reescrito ao invés de reutilizado.

\subsection{Viscosidade}

Quando uma mudança deve ser realizada, usualmente há várias opções para realizar tal mudança. Quando as opções que preservam o design são mais difíceis de serem implementadas do que aquelas que não o preservam (hacks), há alta viscosidade de design. Neste cenário, é fácil fazer a "coisa errada" e é difícil fazer a "coisa certa", ou seja, é difícil preservar e aprimorar o design.

\subsection{Complexidade Desnecessária}

Detecta-se complexidade desnecessária no design quando ele contém muitos elementos inúteis ou não utilizados (\textit{dead code}). Geralmente ocorre quando há muito design inicial (\textit{up-front design}) e não se segue uma abordagem de desenvolvimento iterativa e incremental, de modo que os projetistas tentam prever uma série de futuros requisitos para o sistema e concebem um design demasiadamente flexível ou desnecessariamente sofisticado. Frequentemente apenas algumas previsões acabam se concretizando ao longo do tempo e, neste meio período, o design carrega o peso de elementos e construções não utilizados. O software então se torna complexo e difícil de ser entendido. Design com complexidade muito alta comumente afeta a produtividade, porque quando os desenvolvedores herdam tal projeto, eles gastam muito tempo aprendendo as nuances do design antes que possam efetivamente estendê-lo ou mantê-lo confortavelmente \cite{kerievsky}.

\subsection{Repetição Desnecessária}

Quando há repetição de trechos de código, é sinal de que uma abstração apropriada não foi capturada durante o processo de design (ou inclusive na análise).
Esse problema é frequente e é comum encontrar softwares que contenham dezenas e até centenas de elementos com códigos repetidos. Descobrir a melhor abstração para eliminar a repetição de código geralmente não está na lista de itens de alta prioridade dos desenvolvedores, de maneira que a resolução do problema acaba sendo eternamente postergada. Também, o sistema se torna cada vez mais difícil de entender e principalmente de manter, pois os problemas encontrados em uma unidade de repetição devem ser corrigidos potencialmente em toda repetição, com o agravante de que uma repetição pode ter forma ligeiramente diferente de outra.

\subsection{Opacidade}

Opacidade é a tendência de um módulo ser difícil de ser entendido. Códigos podem ser escritos de maneira clara e expressiva ou de maneira "opaca" e complicada.
A tendência de um código é se tornar mais e mais opaco a medida que o tempo passa e, para que isso seja evitado, é necessário um esforço constante em 
manter esse código claro e expressivo. Uma maneira para prevenir isso, é fazer com que os desenvolvedores se ponham no papel de leitores do código e
refatorem esse código de maneira que qualquer outro leitor poderia entender. Além disso, revisões de código feita por outros desenvolvedores é também
uma possível solução para manter o código menos opaco.


\section{Princípios de Design}
\label{sec:design-oo-principios}

Os princípios comentados nesta seção são muito discutidos por Robert Martin \cite{bob-martin}, e são produto de 
décadas de experiência em engenharia de software.
Eles não são produto de uma única pessoa, mas sim a integração de pensamentos e trabalhos de um grande número de
desenvolvedores de software e pesquisadores, e visam combater todos os sintomas de degradação discutidos na seção \ref{sec:design-degradacao}.

Conhecidos pelo acrônimo \textit{SOLID} (sólido, em português), são eles:

\begin{itemize}
	\item Princípio da Responsabilidade Única (\textit{Single-Responsibility Principle})
	\item Príncipio do Aberto-Fechado (\textit{Open/Closed Principle})
	\item Princípio de Substituição de Liskov (\textit{Liskov Substitution Principle})
	\item Príncipio da Inversão de Dependência (\textit{Dependency-Inversion Principle})
	\item Princípio da Segregação de Interfaces (\textit{Interface Segregation Principle})
\end{itemize}

\subsection{Príncipio da Responsabilidade Única}
\label{subsec:principio-srp}

O termo coesão define a relação entre os elementos de um mesmo módulo \cite{demarco} \cite{pagejones}. Isso significa que
os todos elementos de uma classe que tem apenas uma responsabilidade tendem a se relacionar. Diz-se que uma classe
como essa é uma classe que possui alta coesão (ou que é coesa). Já em uma classe
com muitas responsabilidades diferentes, os elementos tendem a se relacionar apenas em "grupos", ou seja, com os elementos
que tratam de uma das responsabilidades da classe. A esse tipo de classe, diz-se que ela possui uma baixa coesão (ou que não é
coesa).

Robert Martin altera esse conceito de coesão e relaciona coesão com as forças que causam um módulo ou uma classe a mudar. No caso,
o Príncipio de Responsabilidade Única diz que uma classe deve ter apenas uma única razão para mudar \cite{bob-martin}.

Esse príncipio é bem importante no momento em que há uma alteração em alguma funcionalidade do software. Quando isso ocorre,
o programador precisa procurar pelas classes que possuem a responsabilidade a ser modificada. Supondo uma classe que 
possua mais de uma razão para mudar, isso significa que ela é acessada por duas partes do software que fazem coisas diferentes.
Fazer uma alteração em uma das responsabilidades dessa classe pode, de maneira não intencional, quebrar a outra parte
de maneira inesperada. Isso torna o design frágil, como comentado na seção \ref{subsec:fragilidade}.

Para exemplificar isso, imagine uma classe chamada "Nota Fiscal" que, além de representar uma nota fiscal no sistema, ainda
é responsável por persistir as informações em alguma base de dados. Essa classe viola o Princípio da Responsabilidade Única,
pois ela possui mais de uma razão para mudar. A parte de persistência por exemplo, muito provavelmente faz acesso à arcabouços
que lidam com esse tipo de coisa. Se o arcabouço mudar, isso muito provavelmente forcará uma mudança nessa classe, além de 
todo o processo novamente de recompilação, testes e re-implantação dessa classe. Caso o programador esqueça disso, a aplicação
pode quebrar de maneiras imprevisíveis.

Seguindo o princípio, essas duas responsabilidades deveriam estar em classes diferentes: uma classe que representaria a nota
fiscal no sistema, e outra classe que seria responsável por persistir esses dados. Dessa maneira, alterações na forma de
persistência dos dados não implicam em alterações na classe responsável pela representação da nota fiscal no sistema.

\subsection{Princípio do Aberto-Fechado}
\label{subsec:ocp}

O Príncipio do Aberto-Fechado, cunhado por Bertrand Meyer, diz que as entidades do software (como classes, módulos, funções, etc)
devem ser abertas para extensão, mas fechadas para alteração \cite{meyer-ocp}. Se uma simples alteração resulta em uma cascata
de alterações em módulos dependentes, isso cheira à rigidez, conforme descrito na seção \ref{subsec:rigidez}. O príncipio faz então
com que o programador sempre refatore as classes de modo que mudanças desse tipo não causem mais modificações.

Quando esse princípio é aplicado de maneira correta, novas alterações fazem com que o programador adicione novo código, e não
modifique o anterior. Isso é alcançado através de \textit{abstrações}. Linguagens orientadas a objetos, por exemplo, possuem
mecânismos para se criar abstrações (conhecido com interfaces em linguagens como Java ou C\#). Através dessas abstrações,
o programador consegue descrever a maneira em que uma determinada classe deve se portar, mas sem se preocupar em como
essa classe faz isso.

Robert Martin \cite{bob-martin} ilustra o seguinte exemplo em seu livro: Imagine uma classe responsável por desenhar 
um conjunto de figuras geométricas. O código do método responsável por isso, é algo como:

\begin{lstlisting}[frame=trbl]
public class DesenhadorDeFiguras {
	public void desenhaFiguras(List<Object> figuras) {
		for(Object figura : figuras) {
			if(figura instanceof Circulo) ((Circulo)figura).desenhaCirculo();
			if(figura instanceof Quadrado) ((Quadrado)figura).desenhaQuadrado();
		}
	}
}
\end{lstlisting}

Repare que caso uma nova figura geométrica apareça, o código dessa classe deve ser alterado. Uma solução que segue
o príncipio do Aberto-Fechado seria criar uma abstração (uma interface) para figuras geométricas (chamado de \textit{Figura} no código abaixo).
Todas as figuras geométricas então implementam essa interface. Dessa maneira, ao se criar uma nova figura, basta criar uma nova classe
que represente essa figura. O código da classe \textit{DesenhadorDeFiguras} não precisará ser modificado.

O código que exemplifica isso está abaixo:

\begin{lstlisting}[frame=trbl]
public interface Figura {
	void desenha();
}

public class Quadrado implements Figura {
	public void desenha() { /* ... */ }
}

public class Circulo implements Figura {
	public void desenha() { /* ... */ }
}

public class DesenhadorDeFiguras {
	public void desenhaFiguras(List<Figura> figuras) {
		for(Figura figura : figuras) {
			figura.desenha();
		}
	}
}
\end{lstlisting}

\subsection{Princípio de Substituição de Liskov}
\label{subsec:lsp}

O princípio diz que sub-tipos devem ser substituíveis por tipos base. Esse princípio, criado por Barbara Liskov em 1988 \cite{liskov},
é importante já que herança é uma das maneiras para se suportar abstrações e polimorfismo em linguagens orientadas à objeto.

Como visto na seção \ref{subsec:ocp}, o Princípio do Aberto-Fechado se baseia muito no processo de polimorfismo. Imagine o seguinte caso:
a classe base possui um método que aceita como parâmetros valores entre 1 e 1000. Em determinado momento, o programador cria um sub-tipo
e sobrescreve o mesmo método, com a diferença de que esse método agora aceita valores apenas entre 1 e 500. Esse tipo de situação pode
criar problemas difíceis de serem encontrados, já que como a pré-condição da classe base era mais fraca que a da sub-classe, pode haver
algum cliente que faça uso disso; caso a instância do sub-tipo seja passado para esse cliente, ele vai quebrar. O mesmo problema
acontece na pós-condição do método: imagine que esse mesmo método da classe base retorne um número no intervalo de 1 a 10, e na sub-classe
esse método retorne um valor entre 1 e 50. Os clientes da classe base estão esperando uma saída entre 1 e 10, e caso uma instância da
sub-classe seja passada, ela pode retornar valores que o cliente não está preparado para tratar. Isso faz com que o design fique frágil, 
conforme citado na seção \ref{subsec:fragilidade}.  

Um clássico exemplo sobre Príncipio de Substituição de Liskov é o exemplo dos Quadrados e Retângulos. Imagine uma classe Retângulo. Um
retângulo possui dois lados de tamanhos diferentes. Imagine agora uma classe Quadrado (figura geométrica que possui todos os lados
com o mesmo tamanho) que herde de Retângulo, e a única alteração é fazer com que os dois lados tenham o mesmo tamanho. Apesar
de parecer lógico, afinal um Quadrado é um Retângulo com apenas uma condição diferente, a classe Quadrado quebra o Príncipio:
a pré-condição dela é mais forte do que a do quadrado, afinal os dois lados devem ter o mesmo tamanho. 

\subsection{Princípio da Inversão de Dependências}
\label{subsec:dip}

O Príncipio de Inversão de Dependências se baseia em duas afirmações:

\begin{itemize}
	\item Módulos de alto nível não devem depender de módulos de baixo nível. Ambos devem depender de abstrações
	\item Abstrações não devem depender de detalhes. Detalhes devem depender de abstrações
\end{itemize}

Imagine a seguinte classe Copiadora:

\begin{lstlisting}[frame=trbl]
	public class Copiadora {
		public void copiar() {
			LeitorDeXml leitor = new LeitorDeXml();
			EscritorDeSerial escritor = new EscritorDeSerial();
			while(leitor.temCaracteres()) {
				escritor.escreve(leitor.leCaracteres());
			}
		}
	}
\end{lstlisting}

Repare que a classe Copiadora depende de classes de baixo nível (como LeitorDeXml e EscritorDeSerial). Mudanças nessas classes tendem a forçar
mudanças também na classe de alto nível. Uma possível solução para o problema é uma implementação como a abaixo:

\begin{lstlisting}[frame=trbl]
	public interface Leitor {
		boolean temCaracteres();
		String leCaracteres();
	}
	
	public interface Escritor {
		void escreve(String conteudo);
	}
	
	public class Copiadora {
		private Leitor leitor;
		private Escritor escritor;
		
		public Copiadora(Leitor leitor, Escritor escritor) {
			this.leitor = leitor;
			this.escritor = escritor;
		}
		
		public void copiar() {
			while(leitor.temCaracteres()) {
				escritor.escreve(leitor.leCaracteres());
			}
		}
	}
\end{lstlisting}

Agora a classe Copiadora depende apenas de interfaces de alto nível. As classes EscritorDeSerial e LeitorDeXml agora dependem das
abstrações Leitor e Escritor, e cada um implementa a sua respectiva interface, seguindo o princípio da inversão de dependência.

Robert Martin define uma simples heurística para o princípio: "dependa de abstrações". Além disso, ele levanta alguns pontos
que na medida do possível devem ser seguidos:

\begin{itemize}
	\item Nenhuma variável deve guardar uma referência para uma classe concreta
	\item Nenhuma classe deve derivar de uma classe concreta
	\item Nenhum método deve sobrescrever um método implementado por nenhuma de suas classes base
\end{itemize}

Essas heurísticas podem não fazer sentido em alguns casos, por exemplo, para uma classe concreta que não é volátil. Se essa classe
não muda muito e nenhuma classe similar será derivada dessa, então a dependência dessa classe com alguma outra concreta
não é um grande problema.

\subsection{Princípio da Segregação de Interfaces}
\label{subsec:isp}

O princípio diz que os clientes não devem ser forçados a depender de métodos que eles não usam. Quando uma interface não é coesa,
ela contém métodos que são usadas por um grupo de clientes, e outros métodos que são usados por outro grupo de clientes. Apesar de uma
classe poder implementar mais de uma interface, o princípio diz que o cliente da classe deve apenas depender de interfaces
coesas.

Um exemplo típico é o caso de classes que trabalham com interfaces de usuário e classes de negócio que invocam essas classes
de interface. Imagine uma aplicação bancária aonde você tenha 2 operações: saque e depósito. Geralmente a classe de interface 
vai conter dois métodos: um para desenhar a interface de saque e outra para desenhar a interface de depósito. Uma alteração em
um desses métodos, faz com que a outra classe seja reimplantada. Seguindo o princípio, teríamos o seguinte:

\begin{lstlisting}[frame=trbl]
	public interface InterfaceDeSaque {
		void desenhaSaque();
	}
	
	public interface InterfaceDeDeposito {
		void desenhaDeposito();
	}
	
	public class InterfaceDoUsuario implements InterfaceDeSaque, InterfaceDeDeposito {
		// ...
	}
	
	public class Saque {
		public Saque(InterfaceDeSaque ui) { 
			// ...
		}
	}
\end{lstlisting}

A classe \textit{InterfaceDoUsuario} implementa ambas interfaces, mas repare que a classe \textit{Saque}, responsável por
uma das funcionalidades do sistema recebe apenas a interface que tem somente o método que será utilizado por ela.

\section{Métricas e Heurísticas de design}

