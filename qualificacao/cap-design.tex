%% ------------------------------------------------------------------------- %%
\chapter{TDD e sua influência no design}
\label{cap:design}

\section{Introdução}
\label{sec:design-introducao}

Conforme discutido no capítulo \ref{cap:tdd}, TDD é uma pratica focada em design, e não em testes.
Ao escrever um teste antes do código, os programadores contemplam e decidem não somente sobre a interface (como nomes de classes e 
métodos, tipos de retorno e exceções lançadas), mas também no comportamento que se espera de uma determinada classe 
(como o resultado esperado de acordo com determinadas entradas) [TODO 13].

Conforme o sistema é desenvolvido, TDD possibilita um feedback sobre a qualidade tanto da implementação quanto do design. Segundo 
Freeman \cite{GOOS}, escrever testes (i) clarifica o critério de aceitação para o próximo pedaço de software; (ii) encoraja o programador
a escrever componentes fracamente acoplados, de maneira que eles possam ser testados de maneira isolada, e em um nível maior, combinados
com outros componentes; (iii) cria uma especificação executável sobre o que o código faz; e (iv) cria uma suíte de testes de regressão.
Já o processo de rodar os testes possibilita (i) a detecção de erros enquanto o contexto está recente na mente do programador, e (ii)
faz com que o programador saiba quando terminou seu trabalho, diminuindo assim o risco de implementar funcionalidades desnecessárias.

Como sugerido pelas práticas ágeis,
o design de um software deve emergir junto com sua evolução. E, para responder rapidamente à essas mudanças, é necessário
um feedback constante sobre a qualidade do design. Por esse motivo, TDD é considerado uma importante prática na Programação 
Extrema (XP) \cite{XPExplained} e uma estratégia essencial para designs emergentes.

O objetivo deste capítulo é discutir sobre design de software, apresentando
bons príncipios de design orientado a objetos, métricas e heurísticas de design, relacionando-os com a possível influência 
que TDD tem sobre estes pontos.

\section{Design}

\section{Princípios de Design}
\label{sec:design-oo-principios}

Os princípios comentados nesta seção são muito discutidos por Robert Martin \cite{bob-martin}, e são produto de 
décadas de experiência em engenharia de software.
Eles não são produto de uma única pessoa, mas sim a integração de pensamentos e trabalhos de um grande número de
desenvolvedores de software e pesquisadores.

Conhecidos pelo acrônimo \textit{SOLID} (sólido, em português), são eles:

\begin{itemize}
	\item Princípio da Responsabilidade Única (\textit{Single-Responsibility Principle})
	\item Príncipio do Aberto-Fechado (\textit{Open/Closed Principle})
	\item Princípio de Substituição de Liskov (\textit{Liskov Substitution Principle})
	\item Príncipio da Inversão de Dependência (\textit{Dependency-Inversion Principle})
	\item Princípio da Segregação de Interfaces (\textit{Interface Segregation Principle})
\end{itemize}

\subsection{Príncipio da Responsabilidade Única}
\label{subsec:principio-srp}

O termo coesão define a relação entre os elementos de um mesmo módulo \cite{demarco} \cite{pagejones}. Isso significa que
os todos elementos de uma classe que tem apenas uma responsabilidade tendem a se relacionar. Diz-se que uma classe
como essa é uma classe que possui alta coesão (ou que é coesa). Já em uma classe
com muitas responsabilidades diferentes, os elementos tendem a se relacionar apenas em "grupos", ou seja, com os elementos
que tratam de uma das responsabilidades da classe. A esse tipo de classe, diz-se que ela possui uma baixa coesão (ou que não é
coesa).

Robert Martin altera esse conceito de coesão e relaciona coesão com as forças que causam um módulo ou uma classe a mudar. No caso,
o Príncipio de Responsabilidade Única diz que uma classe deve ter apenas uma única razão para mudar \cite{bob-martin}.

Esse príncipio é bem importante no momento em que há uma alteração em alguma funcionalidade do software. Quando isso ocorre,
o programador precisa procurar pelas classes que possuem a responsabilidade a ser modificada. Supondo uma classe que 
possua mais de uma razão para mudar, isso significa que ela é acessada por duas partes do software que fazem coisas diferentes.
Fazer uma alteração em uma das responsabilidades dessa classe pode, de maneira não intencional, quebrar a outra parte
de maneira inesperada. Isso torna o design frágil, como comentado na seção \ref{subsec:fragilidade}.

Para exemplificar isso, imagine uma classe chamada "Nota Fiscal" que, além de representar uma nota fiscal no sistema, ainda
é responsável por persistir as informações em alguma base de dados. Essa classe viola o Princípio da Responsabilidade Única,
pois ela possui mais de uma razão para mudar. A parte de persistência por exemplo, muito provavelmente faz acesso à arcabouços
que lidam com esse tipo de coisa. Se o arcabouço mudar, isso muito provavelmente forcará uma mudança nessa classe, além de 
todo o processo novamente de recompilação, testes e re-implantação dessa classe. Caso o programador esqueça disso, a aplicação
pode quebrar de maneiras imprevisíveis.

Seguindo o princípio, essas duas responsabilidades deveriam estar em classes diferentes: uma classe que representaria a nota
fiscal no sistema, e outra classe que seria responsável por persistir esses dados. Dessa maneira, alterações na forma de
persistência dos dados não implicam em alterações na classe responsável pela representação da nota fiscal no sistema.

\subsection{Princípio do Aberto-Fechado}
\label{subsec:ocp}

\section{Métricas de design}

\section{Heurísticas de designs}

\section{Sintomas de Designs em Degradação}

Quando um design começa a ficar difícil de ser evoluído, o reúso de código se torna mais complicado do que repetir o trecho de código ou 
o custo de se fazer qualquer alteraçõ no design se torna alto, dizemos que que esse design está \textit{degradando}. 
Martin \cite{bob-martin} enumerou alguns sintomas de designs em degradação, chamados também de \textit{maus cheiros de design}. 
Esses sintomas são parecidos com os maus cheiros de código \textit{code smells}, mas em um nível mais alto: esses sintomas
estão presentes na estrutura geral do software ao invés de estarem em apenas um pequeno trecho de código.

Esses sintomas podem ser medidos de forma subjetiva e algumas vezes de forma até objetiva. Geralmente, esses sintomas são causados
por violações de um ou mais príncipios de design, apresentados na seção \ref{sec:design-oo-principios}. 

Muitos desses problemas são relacionados à gerência de dependências e, como comentado por Martin em
uma de suas palestras \cite{bobmartin-infoq}, gerenciar dependências é um dos maiores problemas do processo de desenvolvimento de software.
Quando essa atividade não é feita corretamente, isso gera código que é difícil de manter e reusar. Entretanto, quando essa atividade
é bem feita, o software tende a ser flexível, robusto e suas partes reusáveis.

\subsection{Rigidez}

Rigidez é a tendência do software em se tornar difícil de mudar, mesmo de maneiras simples. Toda mudança causa uma cascata de mudancçs subsequentes em módulos dependentes. Quanto mais módulos precisam ser modificados, maior é a rigidez do design. Quando um design está muito rígido, não se sabe com segurança quando uma mudança terá fim. Mudanças simples passam a demorar muito tempo até serem aplicadas no código e frequentemente acabam superando em várias vezes a estimativa de esforço inicial. Frases como \textit{"isto foi muito mais complicado do que eu imaginei"} tornam-se populares. Neste momento, gerentes de desenvolvimento começam a ficar receosos em permitir que os desenvolvedores consertem problemas não críticos.


\subsection{Fragilidade}
\label{subsec:fragilidade}

Fragilidade é a tendência do software em quebrar em muitos lugares diferentes toda vez que uma única mudança acontece. Frequentemente, os novos problemas ocorrem em áreas não relacionadas conceitualmente com a área que foi mudada, tornando o processo de manutenção demasiadamente custoso, complexo e tedioso. Consertar os novos problemas usualmente passa a resultar em outros novos problemas e assim por diante. Infelizmente, módulos frágeis são comuns em sistemas de software. São estes os módulos que sempre aparecem na lista de bugs a serem corrigidos. Além disto, desenvolvedores começam a ficar receosos de alterar certos trechos de código, pois sabem que estes estão tão frágeis que qualquer mudança simples fatalmente acarretará na introdução de problemas inesperados e de naturezas diversas. 


\subsection{Imobilidade}

Imobilidade é a impossibilidade de se reusar software de outros projetos ou de partes do mesmo projeto. Neste cenário, o módulo que se deseja reutilizar frequentemente tem uma bagagem muito grande de dependências e não possui código claro. Depois de muita investigação, os arquitetos descobrem que o trabalho e o risco de separar as partes desejáveis das indesejáveis são tão grandes, que o módulo acaba sendo reescrito ao invés de reutilizado.

\subsection{Viscosidade}

Quando uma mudança deve ser realizada, usualmente há várias opções para realizar tal mudança. Quando as opções que preservam o design são mais difíceis de serem implementadas do que aquelas que não o preservam (hacks), há alta viscosidade de design. Neste cenário, é fácil fazer a "coisa errada" e é difícil fazer a "coisa certa", ou seja, é difícil preservar e aprimorar o design.

\subsection{Complexidade Desnecessária}

Detecta-se complexidade desnecessária no design quando ele contém muitos elementos inúteis ou não utilizados (\textit{dead code}). Geralmente ocorre quando há muito design inicial (\textit{up-front design}) e não se segue uma abordagem de desenvolvimento iterativa e incremental, de modo que os projetistas tentam prever uma série de futuros requisitos para o sistema e concebem um design demasiadamente flexível ou desnecessariamente sofisticado. Frequentemente apenas algumas previsões acabam se concretizando ao longo do tempo e, neste meio período, o design carrega o peso de elementos e construções não utilizados. O software então se torna complexo e difícil de ser entendido. Design com complexidade muito alta comumente afeta a produtividade, porque quando os desenvolvedores herdam tal projeto, eles gastam muito tempo aprendendo as nuances do design antes que possam efetivamente estendê-lo ou mantê-lo confortavelmente \cite{kerievsky}.

\subsection{Repetição Desnecessária}

Quando há repetição de trechos de código, é sinal de que uma abstração apropriada não foi capturada durante o processo de design (ou inclusive na análise).
Esse problema é frequente e é comum encontrar softwares que contenham dezenas e até centenas de elementos com códigos repetidos. Descobrir a melhor abstração para eliminar a repetição de código geralmente não está na lista de itens de alta prioridade dos desenvolvedores, de maneira que a resolução do problema acaba sendo eternamente postergada. Também, o sistema se torna cada vez mais difícil de entender e principalmente de manter, pois os problemas encontrados em uma unidade de repetição devem ser corrigidos potencialmente em toda repetição, com o agravante de que uma repetição pode ter forma ligeiramente diferente de outra.

\subsection{Opacidade}

Opacidade é a tendência de um módulo ser difícil de ser entendido. Códigos podem ser escritos de maneira clara e expressiva ou de maneira "opaca" e complicada.
A tendência de um código é se tornar mais e mais opaco a medida que o tempo passa e, para que isso seja evitado, é necessário um esforço constante em 
manter esse código claro e expressivo. Uma maneira para prevenir isso, é fazer com que os desenvolvedores se ponham no papel de leitores do código e
refatorem esse código de maneira que qualquer outro leitor poderia entender. Além disso, revisões de código feita por outros desenvolvedores é também
uma possível solução para manter o código menos opaco.


\section{TDD e Design}
2 vantagens gratuitas; gerenciamento de dependencias e codigo facilmente invocavel
experiencia do programador para refatoracao de nivel maior
exemplo da classe de nota fiscal
falar sobre feedback do design
sinergia entre alta testabilidade e codigo bom
