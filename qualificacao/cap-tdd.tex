%% ------------------------------------------------------------------------- %%
\chapter{Test-Driven Development}
\label{cap:tdd}

Test-Driven Development (TDD) é uma prática de desenvolvimento de software, onde o programador deve apenas escrever
um código novo se houver um teste automatizado falhando, e deve também constantemente remover duplicação de dados e de código. 
Essas duas regras implicam no seguinte ciclo: o programador primeiro deve escrever um pequeno teste que falhe (ou que até mesmo não compile), 
em seguida deve fazer o teste passar de maneira mais rápida possível e, por fim, deve refatorar toda a duplicação criada quando o programador
estava simplesmente fazendo o teste passar e possivelmente não escreveu o código mais claro possível \cite{TDDByExample}. 
Esse ciclo é também conhecido como Vermelho-Verde-Refatora (ou Red-Green-Refactor), já que lembram as cores que o programador geralmente 
vê quando faz TDD: o vermelho geralmente significa que o teste está falhando e o verde quando o teste foi executado com sucesso. 

Ao fazer TDD, o programador é obrigado a escrever um teste antes de escrever o código que será testado. TDD faz com que esse 
simples processo sirva para ajudar o time a entender as funcionalidades que os usuários do sistema precisam, e 
a entregar essas funcionalidades de maneira confiável e previsível \cite{GOOS}. TDD usa os testes para clarificar as expectativas
sobre o que um pedaço de código deve fazer [TODO 3]. Além disso, ele cria uma medida concreta de falha, que são os testes de 
unidade que estão falhando). Com essa medida em mãos, o objetivo do programador naquele momento é simplesmente fazer o teste passar. É um
objetivo claro e bem definido, e permite ao programador focar naquele pequeno pedaço de funcionalidade e no trecho de código que ele 
deve escrever para fazer o teste passar \cite{TDDByExample}. 

% levar esse paragrafo para parte sobre design
TDD permite também que o desenvolvedor obtenha feedback sobre o design do sistema. Como sugerido pelas práticas ágeis,
o design de um software deve emergir junto com sua evolução. E, para responder rapidamente à essas mudanças, é necessário
um feedback constante sobre a qualidade do design. Por esse motivo, TDD é considerado uma importante prática na Programação 
Extrema (XP) \cite{XPExplained} e uma estratégia essencial para designs emergentes pois, 
ao escrever um teste antes do código, os programadores contemplam e decidem não somente sobre a interface (como nomes de classes e 
métodos, tipos de retorno e exceções lançadas), mas também no comportamento que se espera de uma determinada classe 
(como o resultado esperado de acordo com determinadas entradas) [TODO 13]. 

Conforme o sistema é desenvolvido, TDD possibilita um feedback sobre a qualidade tanto da implementação quanto do design. Segundo 
Freeman \cite{GOOS}, escrever testes (i) clarifica o critério de aceitação para o próximo pedaço de software; (ii) encoraja o programador
a escrever componentes fracamente acoplados, de maneira que eles possam ser testados de maneira isolada, e em um nível maior, combinados
com outros componentes; (iii) cria uma especificação executável sobre o que o código faz; e (iv) cria uma suíte de testes de regressão.
Já o processo de rodar os testes possibilita (i) a detecção de erros enquanto o contexto está recente na mente do programador, e (ii)
faz com que o programador saiba quando terminou seu trabalho, diminuindo assim o risco de implementar funcionalidades desnecessárias.

\section{O Ciclo} 
\label{sec:tdd-ciclo}

De forma mais ampla, podemos definir o ciclo de TDD da seguinte maneira: (i) adicione um teste; (ii) rode todos os testes e veja o 
novo teste falhar; (iii) escreva o código mais simples que faça o teste passar; (iv) rode todos os testes e veja o novo teste passar; 
(v) refatore para remover duplicação de dados e de código.

As sub-seções abaixo visam explicar cada passo do ciclo de forma mais detalhada, explicando a motivação e o esperado 
em cada um deles.

\subsection{Adicionar um teste}

O primeiro passo do ciclo é escrever um teste para uma nova funcionalidade. Para isso, o programador deve primeiro entender a funcionalidade 
que ele deseja implementar, e dessa forma entender melhor o requisito antes de escrever qualquer linha de código.

Esse teste falhará, afinal a funcionalidade ainda não foi implementada. 

\subsection{Rodar todos os testes e ver o novo teste falhar}

Nesse momento o programador roda todos os seus testes de unidade e verifica se o teste escrito no passo anterior realmente falhou. Em um
primeiro momento esse passo pode parecer desnecessário, pois o programador escreveu um teste para uma funcionalidade que ele ainda nem
implementou, e portanto o teste irá falhar. 

Mas, na prática, esse teste pode não falhar, indicando alguns possíveis problemas, como: talvez o código da classe que está sendo testada
não está reagindo da maneira que o programador pensou que estava (afinal ele esperava por um determinado comportamento quando na verdade a
classe apresentou outro); problemas na implementação do teste, afinal teste também é código, e assim como o código de produção, ele é
totalmente suscetível a falhas.

Portanto, pode-se concluir que ver o novo teste falhar ajuda o programar a validar tanto o código de teste quanto o seu conhecimento
sobre a classe que está sendo testada. 

\subsection{Escreva o código mais simples que faça o teste passar}

O programador deve então escrever o código mais simples possível que faça o teste passar. Nesse momento o programador não deve estar
focado em escrever a solução mais clara (pois isso será feito em um passo posterior), e sim realmente a mais simples.

O objetivo desse passo é evitar que o programador, ao invés de resolver o problema de maneira simples, por algum motivo
implemente uma solução mais complexa, e com isso acrescentando complexidade desnecessária no código. Algumas técnicas como
"Implementação Óbvia" (TODO complementar) e "Triangularização" (TODO complementar) \cite{TDDByExample} podem ajudar o programador
na tarefa de escrever a implementação mais simples possível.

\subsection{Rode todos os testes e veja o novo teste passar}

Assim que o programador escrever o código mais simples que faça o teste passar, ele deve rodar a suíte de testes novamente
para verificar que a nova implementação realmente faz o teste passar. Nesse ponto é importante que o programador rode a suíte 
completa de testes, pois a implementação pode ter feito o novo teste passar, mas pode ter quebrado testes antigos que já existiam na suíte. 

Caso algum teste antigo quebre, o programador deve então voltar um passo atrás, e tentar novamente escrever o código mais simples
que faça o teste que está quebrado passar.

\subsection{Refatore para remover duplicação de dados e de código}

No último passo do ciclo o programador agora deve refatorar o código escrito, procurando remover as duplicações de código ou de dados. 
Conforme comentado acima, o código escrito anteriormente era o mais simples, mas não necessariamente o mais claro possível. O programador
nesse momento tem total liberdade para refatorar, já que tem uma suíte de testes para garantir que o comportamento não será alterado.

Esse é um dos principais passos no ciclo, já que é aqui que o programador se preocupa em melhorar o seu código, tornando-o
mais claro e, por consequência, facilitando sua evolução.

\section{Passos de bebê}

TDD sugere que o programador dê sempre pequenos passos (conhecidos pelo termo em inglês, \textit{baby steps}): deve-se escrever testes 
sempre para a menor funcionalidade possível, escrever o código mais simples que faça o teste passar e fazer sempre 
apenas uma refatoração por vez. 

A justificativa para tal é que quanto maior o passo que o programador dá, mais tempo ele leva para concluir esse passo e, 
consequentemente ele fica mais tempo sem feedback sobre o código. Além disso, faz com que o programador não crie 
soluções mais complexas do que elas precisam ser, tornando o código à longo prazo o mais simples possível.

Em seu livro sobre TDD, Kent Beck sugere a seguinte abordagem inicial para uma classe \textit{Dinheiro}, que permite uma operação de 
multiplicação \cite{TDDByExample}:

\begin{lstlisting}[frame=trbl]
    public void testaMultiplicacao() {
		Dinheiro cinco = new Dinheiro(5);
		cinco.vezes(2);
		assertEquals(10, dinheiro.valor);
	}
\end{lstlisting}

Nesse momento ocorrem alguns erros de compilação já que a classe Dinheiro ainda não foi escrita. Em seguida, Beck escreve
a seguinte classe:

\begin{lstlisting}[frame=trbl]
	class Dinheiro {
		public int valor;
		
		Dinheiro(int valor) {
		}
		
		void vezes(int multiplicador) {
		}
	}
\end{lstlisting}

Nesse momento não existem mais erros de compilação, e é possível executar e ver o teste falhar. O teste falha pois ele esperava
que o atributo \textit{valor} retornasse 10, mas retornou 0. Nesse momento, Beck faz o teste passar da forma mais simples possível,
que é simplesmente inicializar o atributo \textit{valor} da classe \textit{Dinheiro} com o valor 10.

\begin{lstlisting}[frame=trbl]
	public int valor = 10;
\end{lstlisting}

Agora com o teste passando, Beck começa então o passo de refatoração, visando remover duplicação de dados e de código. No exemplo,
existe a clara duplicação de dados entre a classe e o código de teste: o valor 10, que surgiu da multiplicação do 5 por 2. 

\begin{lstlisting}[frame=trbl]
	public int valor = 5 * 2;
\end{lstlisting}

Nesse momento, Beck percebe que não há como remover a duplicação em apenas um passo. Ele então, move a multiplicação para dentro
do método \textit{vezes}:

\begin{lstlisting}[frame=trbl]
	public int valor;
	
	void vezes(int multiplicador) {
		valor = 5 * 2;
	}
\end{lstlisting}

Finalmente ele extrai o valor 5 do parâmetro que é passado para o construtor:

\begin{lstlisting}[frame=trbl]
class Dinheiro {
	public int valor;
	
	Dinheiro(int valor) {
		this.valor = valor;
	}
	
	void vezes(int multiplicador) {
		valor = valor * 2;
	}
}
\end{lstlisting}

Por fim, ele remove o 2 e multiplica agora pelo \textit{multiplicador}:

\begin{lstlisting}[frame=trbl]
class Dinheiro {
	public int valor;
	
	Dinheiro(int valor) {
		this.valor = valor;
	}
	
	void vezes(int multiplicador) {
		valor = valor * multiplicador;
	}
}
\end{lstlisting}

O único teste ainda continua passando, provando que a refatoração foi feita com sucesso. Pode-se observar através
do exemplo acima que os passos dados foram sempre os menores e mais simples possíveis, ou \textit{passos de bebê}, por assim dizer. 
Veja que, mesmo após diversos passos de refatoração, ainda é possível encontrar problemas de design, como o atributo \textit{valor}
declarado como público. Seriam necessários outras rodadas de refatoração para eliminar esse problema.

Uma confusão comum de programadores que experimentam TDD pela primeira vez é a de que fazer passos de bebê o tempo todo faz
com que a produtividade diminua. De fato, fazer passos de bebê durante todo o ciclo faz com que o tempo de desenvolvimento aumente,
já que muitos desses passos são simples demais e poderiam ser pulados por um programador mais experiente. Mas TDD não força o programador
a dar passos de bebê o tempo todo. TDD permite que o mesmo dê passos de bebê quando achar necessário \cite{TDDByExample}: caso
o programador esteja confiante sobre o trecho de código que está escrevendo naquele momento, ele pode dar um passo maior; mas caso ele
não esteja tão confiante, TDD permite a ele ir mais devagar e dar passos de bebê, obtendo feedback mais rápido sobre o código que está escrevendo. 

No exemplo acima, o método \textit{vezes} poderia ser considerado simples por um programador experiente, que optaria por chegar à
mesma solução acima de maneira mais rápida, tomando passos maiores.

---
explicar mais a fundo o ciclo, se baseando no artigo de paris

tdd patterns e red/green bar patterns (beck)

lista de proximas coisas a fazer

definir codigo de producao?

exemplo parecido com o do money (simples e dpeois completo)

definições frouxas

história do tdd

tdd = tfd + refatoracao

refatoracao tanto de baixo nivel quanto de alto nivel


visao do martin sobre tdd

ron jefrries clean code that works